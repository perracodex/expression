/*
 * Copyright (c) 2024-Present Perracodex. Use of this source code is governed by an MIT license.
 */

package io.github.perracodex.expression.engine

import io.github.perracodex.expression.functions.EvalFunction
import io.github.perracodex.expression.functions.FunctionRegistry
import java.math.BigDecimal
import java.math.RoundingMode

/**
 * Evaluates abstract syntax tree nodes generated by the [Parser].
 *
 * It supports various types of nodes including numbers,
 * binary operations, functions, text literals, and unary operations.
 */
class Evaluator(private val decimalPlaces: Int = DECIMAL_PLACES) {

    /**
     * Evaluates the given input string and returns the evaluation result.
     *
     * @param input The input string to be evaluated.
     * @return The result of the evaluation, or null if the input is empty.
     * @throws EvalException If there is an error during the evaluation.
     */
    fun evaluate(input: String): Any? {
        try {
            val treeRoot: ASTNode? = Parser(input = input).parse()

            treeRoot?.let { root ->
                val evaluation: Any = Evaluator().evaluateNode(node = root)

                if (evaluation is Double) {
                    return formatNumber(value = evaluation)
                }

                return evaluation
            }
        } catch (e: Exception) {
            throw EvalException(message = "Error evaluating expression: ${e.message}", cause = e)
        }

        return null
    }

    /**
     * Formats a Double value by limiting to a maximum number of decimal places and removing any trailing zeros.
     * If the resulting number is a whole number, it returns a Long. Otherwise, it returns a Double.
     *
     * @param value The Double value to be formatted.
     * @return A Number which will be either a Long or a Double,
     *         depending on whether the formatted value is a whole number or not.
     */
    private fun formatNumber(value: Double): Number {
        val bigDecimalValue: BigDecimal = BigDecimal(value).setScale(
            decimalPlaces,
            RoundingMode.HALF_UP,
        ).stripTrailingZeros()
        return if (bigDecimalValue.scale() <= 0) bigDecimalValue.toLong() else bigDecimalValue.toDouble()
    }

    /**
     * Evaluates the given [ASTNode] and returns the evaluation result.
     *
     * @param node The AST node to be evaluated.
     * @return The result of the evaluation.
     * @throws EvalException If there is an error during the evaluation.
     */
    private fun evaluateNode(node: ASTNode): Any {
        return when (node) {
            is ASTNode.NumberNode -> node.value
            is ASTNode.TextNode -> node.value
            is ASTNode.BinaryOperationNode -> evaluateBinaryOperation(node = node)
            is ASTNode.UnaryOperationNode -> evaluateUnaryOperation(node = node)
            is ASTNode.FunctionNode -> evaluateFunction(node = node)
        }
    }

    /**
     * Evaluates a binary operation node.
     *
     * @param node The binary operation node to evaluate.
     * @return The result of the binary operation.
     * @throws EvalException If an unknown operator is encountered.
     */
    private fun evaluateBinaryOperation(node: ASTNode.BinaryOperationNode): Any {
        val left: Double = evaluateNode(node = node.left).toString().toDouble()
        val right: Double = evaluateNode(node = node.right).toString().toDouble()

        return when (node.operator.type) {
            Token.Type.PLUS -> left.plus(other = right)
            Token.Type.MINUS -> left.minus(other = right)
            Token.Type.MULTIPLY -> left.times(other = right)
            Token.Type.DIVIDE -> left.div(other = right)
            Token.Type.MODULO -> left.mod(other = right)
            else -> throw EvalException(message = "Unknown binary operator: ${node.operator.type}")
        }
    }

    /**
     * Evaluates a function node by invoking the corresponding function
     * from the [FunctionRegistry].
     *
     * @param node The function node to evaluate.
     * @return The result of the function evaluation.
     * @throws EvalException If the function is not found in the registry.
     */
    private fun evaluateFunction(node: ASTNode.FunctionNode): Any {
        val functionName: String = node.name

        val evalFunction: EvalFunction = FunctionRegistry.get(name = functionName)
            ?: throw EvalException(message = "Function '$functionName' not found")

        val evaluatedArguments: List<Any> = node.arguments.map { evaluateNode(node = it) }
        return evalFunction.evaluate(arguments = evaluatedArguments)
    }

    /**
     * Evaluates a unary operation node.
     *
     * @param node The unary operation node to evaluate.
     * @return The result of the unary operation.
     * @throws EvalException If an unknown unary operator is encountered.
     */
    private fun evaluateUnaryOperation(node: ASTNode.UnaryOperationNode): Any {
        val operand: Double = evaluateNode(node = node.operand) as Double

        return when (node.operator.type) {
            Token.Type.MINUS -> -operand
            Token.Type.PLUS -> operand
            else -> throw EvalException(message = "Unknown unary operator: ${node.operator.type}")
        }
    }

    companion object {
        /** The default number of decimal places to round to. */
        private const val DECIMAL_PLACES: Int = 4
    }
}

/**
 * Exception class for handling evaluation errors.
 *
 * @param message The error message describing the evaluation error.
 * @param cause The original exception that caused this error (optional).
 */
class EvalException(message: String, cause: Throwable? = null) : Exception(message, cause)
